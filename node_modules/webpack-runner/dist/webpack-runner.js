Object.defineProperty(exports, "__esModule", { value: true });
const Getopt = require("node-getopt");
const fs = require("fs");
const path = require("path");
const webpack = require("webpack");
const error_formatter_1 = require("./error-formatter");
const warning_formatter_1 = require("./warning-formatter");
let getopt = new Getopt([
    ['C', 'config=ARG', 'Path to webpack config file'],
    ['', 'profile=ARG', 'Outputs webpack analyzer stats'],
    ['w', 'watch', 'Runs in continuous mode, watching for changes'],
    ['h', 'help', 'Displays this help']
]);
let opt = getopt
    .bindHelp()
    .parseSystem();
if (!opt.options['config']) {
    process.stderr.write("Missing required --config option\n\n");
    process.stderr.write(getopt.getHelp());
    process.exit(1);
}
let configPath = path.resolve(opt.options['config']);
let isWatchMode = !!opt.options['watch'];
let isProfile = !!opt.options['profile'];
let profilePath = isProfile ? path.resolve(opt.options['profile']) : void 0;
let config;
try {
    config = require(configPath);
}
catch (e) {
    process.stderr.write(`Couldn't open webpack config file "${configPath}". ${e.stack}\n`);
    process.exit(1);
}
let runningCount = 0;
let startTime = 0;
function onWatchCompileEnded() {
    if (runningCount) {
        runningCount--;
    }
}
function printBuildFinished() {
    let totalTime = (new Date).getTime() - startTime;
    process.stdout.write("Build finished. (" + totalTime + "ms)\n");
}
let outputPlugin = {
    apply(compiler) {
        let onCompile = function (params) {
            if (!runningCount) {
                startTime = (new Date).getTime();
                process.stdout.write("Build started.\n");
            }
            runningCount++;
        };
        let onDone = function (stats) {
            onWatchCompileEnded();
        };
        let onFailed = function (error) {
            onWatchCompileEnded();
        };
        compiler.hooks.compile.tap("webpack-runner", onCompile);
        compiler.hooks.done.tap("webpack-runner", onDone);
        compiler.hooks.failed.tap("webpack-runner", onFailed);
    }
};
if (Array.isArray(config)) {
    config.forEach(c => applyConfigOverrides(c));
}
else {
    applyConfigOverrides(config);
}
function applyConfigOverrides(config) {
    if (isWatchMode) {
        config.plugins = config.plugins || [];
        config.plugins.push(outputPlugin);
    }
    config.watch = !!isWatchMode;
    config.profile = !!isProfile;
}
function isMultiStats(stats) {
    return !('compilation' in stats);
}
function isMultiConfig(config) {
    return typeof config.length !== "undefined";
}
function collectWarnings(stats) {
    let warnings = [];
    if (isMultiStats(stats)) {
        stats.stats.forEach(s => warnings = warnings.concat(s.compilation.warnings));
    }
    else {
        warnings = stats.compilation.warnings;
    }
    return warnings;
}
function collectErrors(stats) {
    let errors = [];
    if (isMultiStats(stats)) {
        stats.stats.forEach(s => errors = errors.concat(s.compilation.errors));
    }
    else {
        errors = stats.compilation.errors;
    }
    return errors;
}
function handler(err, stats) {
    if (err) {
        process.stdout.write(error_formatter_1.formatGeneralError(configPath, 1, 1, err.message) + "\n");
        if (isWatchMode) {
            printBuildFinished();
        }
        process.exit(1);
    }
    // Output warnings before errors to ensure errors come up on top in the editor
    if (stats.hasWarnings()) {
        let warnings = warning_formatter_1.formatWarnings(collectWarnings(stats));
        warnings.forEach(function (warning) {
            process.stdout.write(warning + "\n");
        });
    }
    if (stats.hasErrors()) {
        let errors = error_formatter_1.formatErrors(collectErrors(stats));
        errors.forEach(function (error) {
            process.stdout.write(error + "\n");
        });
        if (!isWatchMode) {
            process.exit(1);
        }
    }
    if (isWatchMode) {
        printBuildFinished();
    }
    if (isProfile) {
        fs.writeFileSync(profilePath, JSON.stringify(stats.toJson()));
        process.exit(0);
    }
    if (!isWatchMode) {
        process.exit(0);
    }
}
;
if (isMultiConfig(config)) {
    webpack(config, handler);
}
else {
    webpack(config, handler);
}
