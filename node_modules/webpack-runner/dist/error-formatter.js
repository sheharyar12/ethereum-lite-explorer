Object.defineProperty(exports, "__esModule", { value: true });
const stripAnsi = require("strip-ansi");
/**
 * Formats an error in a way that is recognizable by an IDE
 *
 * $FILE($LINE,$COL): $MSG
 *
 * e.g.
 * /some/full/path/to/file.js (1,3): Some error happened
 */
function formatGeneralError(filePath, line, column, message) {
    return filePath + ' (' + line + ',' + column + '): error WEBPACK: ' + message;
}
exports.formatGeneralError = formatGeneralError;
/**
 * Interprets errors generated by webpack and formats them
 */
function formatBuildError(error) {
    let filePath;
    let line;
    let column;
    let message;
    switch (error.name) {
        case 'ModuleParseError':
            filePath = error.module.resource;
            line = error.error.loc.line;
            column = error.error.loc.column;
            message = error.error.toString();
            break;
        case 'ModuleNotFoundError':
            filePath = error.module.resource;
            line = error.dependencies[0].loc.start.line;
            column = error.dependencies[0].loc.start.column;
            message = error.error.toString();
            break;
        case 'ModuleBuildError':
            filePath = error.module.resource;
            line = 1;
            column = 1;
            message = error.message;
            break;
        case 'ModuleError':
            // TODO: is this really needed anymore? ts-loader errors
            // should fall under default now
            if (error.module.resource.match(/\.ts$/)) {
                return error.message.trim();
            }
        //nobreak
        default:
            if (error.loaderSource === "ts-loader") {
                let file;
                if (error.file) {
                    file = error.file;
                }
                else if (error.module && error.module.resource) {
                    file = error.module.resource;
                }
                filePath = file;
                line = error.location ? error.location.line : 1;
                column = error.location ? error.location.character : 1;
                message = error.rawMessage || "error " + stripAnsi(error.message).match(/TS\d+: [\s\S]*$/)[0];
                return filePath + ' (' + line + ',' + column + '): ' + message;
            }
            if (error.rawMessage && error.file && error.location) {
                // Looks like a standard error object
                filePath = error.file;
                line = error.location.line;
                column = error.location.character;
                // This treats fork-ts-checker errors nicely
                let match = error.rawMessage.match(/^error ([a-z0-9-_]+: [\s\S]*)$/i);
                if (match) {
                    message = "error " + match[1];
                    return filePath + ' (' + line + ',' + column + '): ' + message;
                }
                message = error.rawMessage;
                break;
            }
            return 'Unhandled error type `' + error.name + '`: ' + error.message;
    }
    return formatGeneralError(filePath, line, column, message);
}
/**
 * Formats an array of webpack errors
 */
function formatErrors(errors) {
    var ret = [];
    if (errors && errors.length) {
        for (var i = 0; i < errors.length; ++i) {
            if (errors[i].name === 'ModuleParseError' && errors[i].message.match(/ts-loader/)) {
                // Let typescript loader report parse errors
                continue;
            }
            ret.push(formatBuildError(errors[i]));
        }
    }
    return ret;
}
exports.formatErrors = formatErrors;
