var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { HttpRequestError } from "./HttpRequestError";
export var DataType;
(function (DataType) {
    /** data is a {key: value} object which will be stringified before being sent */
    DataType[DataType["Json"] = 0] = "Json";
    /** data is passed directly to XMLHttpRequest#send without any preprocessing */
    DataType[DataType["Raw"] = 1] = "Raw";
})(DataType || (DataType = {}));
/**
 * Promise-based wrapper around XMLHttpRequest
 *
 * Expects response status to be 2xx. Throws HttpRequestError otherwise.
 *
 * Example:
 * ```ts
 * try {
 *     let data = await (new HttpRequest()).fetch("/posts");
 *     console.log(data)
 * } catch (e) {
 *     if (e instanceof HttpRequestError) {
 *         if (e.status === 504) {
 *             // do something special
 *         }
 *     }
 * }
 * ```
 */
export class HttpRequest {
    fetch(url, options) {
        return new Promise((resolve, reject) => {
            let request = new XMLHttpRequest();
            request.addEventListener("load", e => {
                let target = e.target;
                if (target.status >= 200 && target.status < 300) {
                    resolve(target.responseText);
                }
                else {
                    reject(new HttpRequestError(target.status, target.response));
                }
            });
            request.addEventListener("error", e => {
                reject(e);
            });
            let data = void 0;
            let method = "GET";
            if (options) {
                if (options.method) {
                    method = options.method;
                }
            }
            request.open(method, url, true);
            if (options) {
                if (options.timeout) {
                    request.timeout = options.timeout;
                }
                if (options.data) {
                    if (method.toLowerCase() === "get") {
                        throw new Error(`Can't send data with GET method. Use POST instead`);
                    }
                    let dataType = options.dataType || DataType.Json;
                    if (dataType === DataType.Json) {
                        request.setRequestHeader("Content-Type", "application/json; charset=UTF-8");
                        data = JSON.stringify(options.data);
                    }
                    else {
                        data = options.data;
                    }
                }
                const headers = options.headers;
                if (headers) {
                    Object.keys(headers).forEach(headerName => {
                        request.setRequestHeader(headerName, headers[headerName]);
                    });
                }
            }
            request.send(data);
        });
    }
    fetchJson(url, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const r = yield this.fetch(url, options);
            return JSON.parse(r);
        });
    }
}
//# sourceMappingURL=HttpRequest.js.map