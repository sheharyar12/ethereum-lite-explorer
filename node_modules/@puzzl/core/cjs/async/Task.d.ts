import { CancellationToken } from "./cancellation";
export interface IAsyncCallback<TResult> {
    (cancellationToken: CancellationToken): Promise<TResult>;
}
/**
 * Wraps an async function allowing to do actions based on its state of execution
 * (run, re-run, cancel, wait to finish)
 *
 * Similar to a regular Promise with a few key differences:
 * 1. The constructor argument is not executed immediately, but instead when start() is invoked.
 * 2. We can intercept the result (or the rejection/error) regardless of the current state of the task
 * 3. We can cancel/stop the task, by providing a CancellationToken to the constructor argument
 *
 * Example:
 * ```typescript
 * interface IBlogPost {
 *      title: string;
 * }
 * let fetchTask = new Task<IBlogPost>(() => fetch("/data.json"));
 * //... in some click handler
 * fetchTask.cancel(); // Cancels if necessary
 * let blogPost = await fetchTask.start();
 * console.log(blogPost.title);
 * ```
 */
export declare class Task<TResult> {
    private func;
    private status;
    private lastResult;
    private lastError;
    private tokenSource;
    private onTaskEnded;
    constructor(func: IAsyncCallback<TResult>);
    /** Reset the task to its initial (not started) state */
    reset(): Promise<void>;
    /** Cancel a running task */
    cancel(): void;
    start(): Promise<TResult>;
    /** Waits for task completion and returns the result (or throws an error respectively) */
    wait(): Promise<TResult>;
    /** Starts the task or waits for completion if already started */
    startOrWait(): Promise<TResult>;
}
//# sourceMappingURL=Task.d.ts.map