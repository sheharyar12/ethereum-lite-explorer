"use strict";
// See https://gist.github.com/danharper/ad6ca574184589dea28d
// Similar to the CancellationToken API from C#
Object.defineProperty(exports, "__esModule", { value: true });
const EventDispatcher_1 = require("../../event/EventDispatcher");
const CancellationToken_1 = require("./CancellationToken");
const internal_1 = require("./internal");
/**
 * A token source creates a `CancellationToken` and has the ability to cancel it.
 * The token is passed to cancellable functions as a parameter
 *
 * e.g:
 * ```typescript
 * async function caller() {
 *     let tokenSource = new CancellationTokenSource();
 *     try {
 *          await cancellable(tokenSource.token);
 *     } catch (e) {
 *         if (e instanceof OperationCanceledError) {
 *             console.warn("Cancelled");
 *         } else {
 *             throw e;
 *         }
 *     }
 * }
 * async function cancellable(token: CancellationToken) {
 *     // Long-running iteration
 *     for (let i = 0; i < 1000; i++) {
 *         await new Promise(resolve => setTimeout(resolve, 1000));
 *         // Check if the token is cancelled after every iteration
 *         token.throwIfCancelled();
 *     }
 * }
 * ```
 */
class CancellationTokenSource {
    constructor() {
        this.onCancel = new EventDispatcher_1.EventDispatcher();
        this.token = new CancellationToken_1.CancellationToken(this);
    }
    /**
     * Issues token cancellation and notifies any registered callbacks
     */
    cancel() {
        this.token[internal_1.CANCEL]();
        this.onCancel.dispatch(this, void 0);
    }
    /**
     * @internal method only callable from CancellationToken
     */
    [internal_1.REGISTER](callback) {
        this.onCancel.subscribe(() => callback());
        if (this.token.isCancelled()) {
            callback();
        }
    }
}
exports.CancellationTokenSource = CancellationTokenSource;
//# sourceMappingURL=CancellationTokenSource.js.map