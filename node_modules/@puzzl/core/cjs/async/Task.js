"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const EventDispatcher_1 = require("../event/EventDispatcher");
const cancellation_1 = require("./cancellation");
var TaskStatus;
(function (TaskStatus) {
    TaskStatus[TaskStatus["NotStarted"] = 0] = "NotStarted";
    TaskStatus[TaskStatus["InProgress"] = 1] = "InProgress";
    TaskStatus[TaskStatus["Finished"] = 2] = "Finished";
    TaskStatus[TaskStatus["Error"] = 3] = "Error";
})(TaskStatus || (TaskStatus = {}));
/**
 * Wraps an async function allowing to do actions based on its state of execution
 * (run, re-run, cancel, wait to finish)
 *
 * Similar to a regular Promise with a few key differences:
 * 1. The constructor argument is not executed immediately, but instead when start() is invoked.
 * 2. We can intercept the result (or the rejection/error) regardless of the current state of the task
 * 3. We can cancel/stop the task, by providing a CancellationToken to the constructor argument
 *
 * Example:
 * ```typescript
 * interface IBlogPost {
 *      title: string;
 * }
 * let fetchTask = new Task<IBlogPost>(() => fetch("/data.json"));
 * //... in some click handler
 * fetchTask.cancel(); // Cancels if necessary
 * let blogPost = await fetchTask.start();
 * console.log(blogPost.title);
 * ```
 */
class Task {
    constructor(func) {
        this.func = func;
        this.status = TaskStatus.NotStarted;
        this.onTaskEnded = new EventDispatcher_1.EventDispatcher();
        this.tokenSource = new cancellation_1.CancellationTokenSource();
    }
    /** Reset the task to its initial (not started) state */
    reset() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.status === TaskStatus.InProgress) {
                throw new Error(`Can't reset a running task`);
            }
            this.status = TaskStatus.NotStarted;
            this.lastResult = (void 0);
            this.lastError = void 0;
        });
    }
    /** Cancel a running task */
    cancel() {
        if (this.status === TaskStatus.InProgress) {
            this.tokenSource.cancel();
        }
    }
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.status !== TaskStatus.NotStarted) {
                throw new Error(`Task already started or completed`);
            }
            try {
                this.lastError = void 0;
                this.lastResult = (void 0);
                this.status = TaskStatus.InProgress;
                this.lastResult = yield this.func(this.tokenSource.token);
                this.status = TaskStatus.Finished;
            }
            catch (e) {
                this.lastError = e;
                this.status = TaskStatus.Error;
            }
            this.onTaskEnded.dispatch(this, void 0);
            if (this.status === TaskStatus.Error) {
                throw this.lastError;
            }
            else {
                return this.lastResult;
            }
        });
    }
    /** Waits for task completion and returns the result (or throws an error respectively) */
    wait() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.status === TaskStatus.Error) {
                return Promise.reject(this.lastError);
            }
            else if (this.status === TaskStatus.Finished) {
                return Promise.resolve(this.lastResult);
            }
            else if (this.status === TaskStatus.InProgress) {
                return new Promise((resolve, reject) => {
                    this.onTaskEnded.subscribeOnce(() => {
                        if (this.status === TaskStatus.Finished) {
                            resolve(this.lastResult);
                        }
                        else {
                            reject(this.lastError);
                        }
                    });
                });
            }
            else if (this.status === TaskStatus.NotStarted) {
                throw new Error(`Can't wait for task that was not even started`);
            }
            else {
                throw new Error(`Unknown task state ${this.status}`);
            }
        });
    }
    /** Starts the task or waits for completion if already started */
    startOrWait() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.status === TaskStatus.NotStarted) {
                return yield this.start();
            }
            else {
                return yield this.wait();
            }
        });
    }
}
exports.Task = Task;
//# sourceMappingURL=Task.js.map