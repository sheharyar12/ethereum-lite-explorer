import * as uuid from "uuid/v4";
export class PageStructureReader {
    constructor(defs, validator, ownerPlugins, logger) {
        this.defs = defs;
        this.validator = validator;
        this.ownerPlugins = ownerPlugins;
        this.logger = logger;
    }
    read(pagesConfig) {
        this.validator.validate(pagesConfig);
        return pagesConfig.map(pageConfig => this.readNode(pageConfig)).filter(p => !!p);
    }
    readModuleMap(modules) {
        this.validator.validateModuleMap(modules);
        return this.mapObjectKeys(modules, n => this.readNode(n));
    }
    readNode(node, parent) {
        let type = node.def;
        let def;
        try {
            def = this.defs.get(type);
        }
        catch (e) {
            this.logger.error(`Entity "${type}" is not exposed by any plugin`);
            return void 0;
        }
        if (type.match(/^page:\/\//)) {
            let page = {
                pluginUri: this.ownerPlugins.get(def),
                uri: type,
                def: def,
                uiStateContainer: {},
                options: node.options,
                children: {}
            };
            page.children = this.mapObjectKeys((node.children || {}), n => this.readNode(n, page));
            return page;
        }
        else if (type.match(/^context:\/\//)) {
            let context = {
                pluginUri: this.ownerPlugins.get(def),
                uri: type,
                def: def,
                pageCritical: !!node.pageCritical,
                parent,
                children: []
            };
            context.children = node.children.map(n => this.readNode(n, context))
                .filter(n => !!n);
            return context;
        }
        else if (type.match(/^module:\/\//)) {
            let m = {
                pluginUri: this.ownerPlugins.get(def),
                uuid: uuid(),
                uri: type,
                def: def,
                pageCritical: !!node.pageCritical,
                options: node.options,
                parent
            };
            if (node.children) {
                m.children = this.mapObjectKeys(node.children, n => this.readNode(n, m));
            }
            return m;
        }
        throw new Error(`Unknown node type for def "${type}"`);
    }
    mapObjectKeys(o, readNode) {
        return Object.keys(o).map(slotType => ([
            slotType, o[slotType].map(readNode).filter(n => !!n)
        ])).reduce((record, entries) => {
            record[entries[0]] = entries[1];
            return record;
        }, {});
    }
}
//# sourceMappingURL=PageStructureReader.js.map