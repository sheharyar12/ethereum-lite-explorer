import { __decorate } from "tslib";
import * as React from "react";
import { Route, BrowserRouter, Switch, Redirect } from "react-router-dom";
import { observer, Observer } from "mobx-react";
import { SidebarMobileStore } from "../SidebarMobileStore";
import { PageWrapper } from "./PageWrapper";
import { LiveData } from "./LiveData";
import { DataLoader } from "../DataLoader";
import { DataContext } from "./DataContext";
import { ErrorBoundary } from "@alethio/ui/lib/util/react/ErrorBoundary";
import { LinkContext } from "./LinkContext";
import { mapModuleData } from "../mapModuleData";
import { PluginTranslationStore } from "../PluginTranslationStore";
import { HelpMode } from "./HelpMode";
import { observable } from "mobx";
import { ModuleContainer } from "./ModuleContainer";
import { ModuleFrame } from "./ModuleFrame";
let PageRenderer = class PageRenderer extends React.Component {
    constructor(props) {
        super(props);
        this.dataLoaders = new Map();
        this.rootContext = {};
        this.toolbarUiState = {};
        this.sidebarMobileStore = new SidebarMobileStore();
        this.helpMode = new HelpMode();
        this.linkContext = {
            pages: this.props.pages
        };
        this.translationStore = new PluginTranslationStore(this.props.plugins, this.props.pluginConfigMetas, this.props.defaultLocale);
        this.translationStore.loadTranslations(this.props.locale)
            .catch(e => this.props.logger.error(e));
    }
    componentDidUpdate(prevProps) {
        if (this.props.locale !== prevProps.locale) {
            this.translationStore.loadTranslations(this.props.locale)
                .catch(e => this.props.logger.error(e));
        }
    }
    render() {
        if (!this.translationStore.isLoaded()) {
            return null;
        }
        let context = this.rootContext;
        let uiStateContainer = this.toolbarUiState;
        let rootModules = this.props.rootModules;
        let dataAdapterTypes = this.collectAdapterUris(rootModules);
        let dataLoader = this.createDataLoader("internal://root", dataAdapterTypes, this.props.dataAdapters);
        let slots = this.renderChildren(rootModules, dataLoader, context, uiStateContainer);
        return React.createElement(LinkContext.Provider, { value: this.linkContext },
            React.createElement(BrowserRouter, { basename: this.props.basePath },
                React.createElement(DataContext, { context: context, dataLoader: dataLoader }, this.props.children({
                    routes: this.renderPages(),
                    slots,
                    sidebarMobileStore: this.sidebarMobileStore,
                    helpMode: this.helpMode
                }))));
    }
    renderPages() {
        return React.createElement(Switch, null,
            this.props.pages.reduce((routes, page) => {
                routes.push(...this.renderPageRoutes(page));
                return routes;
            }, []),
            React.createElement(Route, { render: () => this.props.renderErrorPage() }));
    }
    renderPageRoutes(page) {
        let paths = page.def.paths;
        return Object.keys(paths).map(path => (React.createElement(Route, { exact: true, key: path, path: path, render: ({ match }) => {
                const createContext = paths[path];
                if (typeof createContext === "function") {
                    let context = createContext(match.params);
                    if (!context) {
                        return this.props.renderErrorPage();
                    }
                    if (typeof context === "string") {
                        return React.createElement(Redirect, { to: context });
                    }
                    return this.renderPageContent(page, context);
                }
                else {
                    let dataAdapterUris = createContext.dataAdapters.map(adapter => adapter.ref);
                    let optionalAdapterUris = createContext.dataAdapters
                        .filter(adapter => !!adapter.optional)
                        .map(adapter => adapter.ref);
                    dataAdapterUris = this.filterMissingAdapters(dataAdapterUris, optionalAdapterUris);
                    let dataLoader = this.createDataLoader(path, dataAdapterUris, this.props.dataAdapters);
                    return React.createElement(DataContext, { context: match.params, dataLoader: dataLoader },
                        React.createElement(Observer, null, () => {
                            if ([...dataLoader.getData().values()].some(v => !v.isLoaded())) {
                                return null;
                            }
                            let context = createContext.create(match.params, dataLoader.getData());
                            if (!context) {
                                return null;
                            }
                            return this.renderPageContent(page, context);
                        }));
                }
            } })));
    }
    createDataLoader(cacheKey, dataAdapterTypes, dataAdapters, isRoot) {
        if (this.dataLoaders.has(cacheKey)) {
            return this.dataLoaders.get(cacheKey);
        }
        let dataLoader = new DataLoader(dataAdapterTypes, dataAdapters, this.props.logger, isRoot);
        this.dataLoaders.set(cacheKey, dataLoader);
        return dataLoader;
    }
    collectAdapterUris(childrenMap) {
        let dataAdapterUris = new Set();
        let requiredUris = new Set();
        Object.values(childrenMap).forEach(children => {
            children.forEach(child => {
                let collected;
                if (this.isContext(child)) {
                    collected = child.def.dataAdapters.map(adapter => ({
                        uri: adapter.ref,
                        optional: !!adapter.optional
                    }));
                }
                else {
                    collected = child.def.dataAdapters.map((adapter, i) => {
                        if (this.isRefAdapterConfig(adapter)) {
                            return { uri: adapter.ref, optional: !!adapter.optional };
                        }
                        else {
                            let adapterName = `local-adapter://${child.uuid}/${i}`;
                            this.props.dataAdapters.add(adapterName, adapter.def);
                            return { uri: adapterName, optional: !!adapter.optional };
                        }
                    });
                }
                collected.forEach(({ uri, optional }) => {
                    dataAdapterUris.add(uri);
                    if (!optional) {
                        requiredUris.add(uri);
                    }
                });
                if (this.isContext(child) || !child.children) {
                    return;
                }
                this.collectAdapterUris(child.children).forEach(uri => {
                    dataAdapterUris.add(uri);
                    requiredUris.add(uri);
                });
            });
        });
        let optionalAdapterUris = [...dataAdapterUris].filter(uri => !requiredUris.has(uri));
        return this.filterMissingAdapters([...dataAdapterUris], optionalAdapterUris);
    }
    filterMissingAdapters(adapterUris, optionalAdapterUris) {
        return adapterUris.filter(adapterUri => {
            if (optionalAdapterUris.find(optionalUri => optionalUri === adapterUri) &&
                !this.props.dataAdapters.has(adapterUri)) {
                return false;
            }
            return true;
        });
    }
    collectPageCriticalDataAdapterTypes(children) {
        let dataAdapterTypes = new Set();
        Object.values(children).forEach(modules => {
            modules.forEach(m => {
                if (m.pageCritical) {
                    if (this.isContext(m)) {
                        m.def.dataAdapters
                            .filter(d => !d.optional)
                            .map(adapter => adapter.ref)
                            .forEach(t => dataAdapterTypes.add(t));
                    }
                    else {
                        m.def.dataAdapters.filter(d => !d.optional).map((adapter, i) => {
                            if (this.isRefAdapterConfig(adapter)) {
                                return adapter.ref;
                            }
                            else {
                                let adapterName = `local-adapter://${m.uuid}/${i}`;
                                this.props.dataAdapters.add(adapterName, adapter.def);
                                return adapterName;
                            }
                        }).forEach(t => dataAdapterTypes.add(t));
                    }
                }
                if (this.isContext(m) || !m.children) {
                    return;
                }
                this.collectPageCriticalDataAdapterTypes(m.children).forEach(t => dataAdapterTypes.add(t));
            });
        });
        return dataAdapterTypes;
    }
    isPromise(thunk) {
        return !!thunk.then;
    }
    renderPageContent(page, context) {
        let dataAdapterTypes = this.collectAdapterUris(page.children);
        let dataLoader = this.createDataLoader(page, dataAdapterTypes, this.props.dataAdapters, true);
        let PageTemplate = page.def.getPageTemplate();
        let pageProps = {
            translation: this.translationStore.getTranslations(page.pluginUri),
            sidebarVisible: this.sidebarMobileStore.isSidebarVisible,
            slots: this.renderChildren(page.children, dataLoader, context, page.uiStateContainer),
            options: page.options
        };
        let pageCriticalAdapterTypes = [...this.collectPageCriticalDataAdapterTypes(page.children)];
        let pageElement;
        if (this.isPromise(PageTemplate) || pageCriticalAdapterTypes.length) {
            let contentComponentPromise = Promise.resolve(PageTemplate).then(C => (liveProps) => React.createElement(C, Object.assign({}, liveProps)));
            const getErrorPlaceholder = page.def.getErrorPlaceholder;
            const getLoadingPlaceholder = page.def.getLoadingPlaceholder;
            pageElement = React.createElement(LiveData, { requiredAdapterTypes: pageCriticalAdapterTypes, asyncData: dataLoader.getData(), logger: this.props.logger, ContentComponent: contentComponentPromise, ErrorComponent: props => getErrorPlaceholder ? getErrorPlaceholder(props) :
                    this.props.renderErrorPlaceholder(), LoadingComponent: props => getLoadingPlaceholder ? getLoadingPlaceholder(props) :
                    this.props.renderLoadingPlaceholder(), contentProps: pageProps });
        }
        else {
            pageElement = React.createElement(PageTemplate, Object.assign({}, pageProps));
        }
        return React.createElement(DataContext, { context: context, dataLoader: dataLoader },
            React.createElement(PageWrapper, { routeParams: context, hasSidebar: !!page.def.hasSidebar, sidebarMobileStore: this.sidebarMobileStore }, pageElement));
    }
    renderContext(contextConfig, parentDataLoader, parentContext, dataAdapters, uiStateContainer) {
        let dataAdapterTypes = this.collectAdapterUris({
            modules: contextConfig.children
        });
        let dataLoader = this.createDataLoader(contextConfig, dataAdapterTypes, dataAdapters);
        return React.createElement(Observer, null, () => {
            let requiredAdapterTypes = contextConfig.def.dataAdapters.filter(adapter => !adapter.optional).map(adapter => adapter.ref);
            if (requiredAdapterTypes.some(type => !parentDataLoader.getData().get(type).isLoaded())) {
                return null;
            }
            const context = contextConfig.def.create(parentContext, parentDataLoader.getData());
            if (!context) {
                return null;
            }
            return React.createElement(DataContext, { context: context, dataLoader: dataLoader }, contextConfig.children.map((m, i) => this.renderChild(m, i, dataLoader, context, uiStateContainer)));
        });
    }
    isContext(child) {
        return !!child.def.create;
    }
    isModule(child) {
        return !!child.def.getContentComponent;
    }
    isRefAdapterConfig(config) {
        return !!config.ref;
    }
    renderChildren(children, dataLoader, context, uiStateContainer) {
        let renderedModules = Object.entries(children).reduce((acc, [slotType, modules]) => {
            acc[slotType] = modules.map((mod, i) => this.renderChild(mod, i, dataLoader, context, uiStateContainer));
            return acc;
        }, {});
        return renderedModules;
    }
    renderChild(child, index, dataLoader, context, uiStateContainer) {
        return React.createElement(ErrorBoundary, { errorEl: null, logger: this.props.logger, key: index }, this.isContext(child) ?
            this.renderContext(child, dataLoader, context, dataLoader.dataAdapters, uiStateContainer) :
            this.renderModule(child, dataLoader, uiStateContainer, context));
    }
    renderModule(m, dataLoader, uiStateContainer, context) {
        let children = m.children ?
            this.renderChildren(m.children, dataLoader, context, uiStateContainer) : void 0;
        let hasHelp = !!m.def.getHelpComponent;
        let { HelpComponent } = this.props;
        let contentComponentPromise = m.def.getContentComponent().then(C => observer((liveProps) => React.createElement(React.Fragment, null,
            React.createElement(ModuleContainer, { style: m.def.getWrapperStyle ? m.def.getWrapperStyle(liveProps) : {} },
                React.createElement(Observer, null, () => this.helpMode.isActive() && !(!hasHelp && this.moduleHasAncestorWithHelp(m)) ?
                    React.createElement(ModuleFrame, { hasHelp: hasHelp, onClick: hasHelp ? () => this.helpOpenFor = m : void 0 }) : null),
                React.createElement(Observer, null, () => React.createElement(React.Fragment, null, this.helpMode.isActive() && this.helpOpenFor === m && HelpComponent ?
                    React.createElement(HelpComponent, { module: m, onRequestClose: () => this.helpOpenFor = void 0 },
                        React.createElement(LiveData, { logger: this.props.logger, ContentComponent: Promise.resolve(observer(m.def.getHelpComponent())), contentProps: liveProps, requiredAdapterTypes: [], asyncData: new Map() })) : null)),
                React.createElement(C, Object.assign({}, m.def.getContentProps(liveProps)))))));
        const getErrorPlaceholder = m.def.getErrorPlaceholder;
        const getLoadingPlaceholder = m.def.getLoadingPlaceholder;
        let requiredAdapterTypes = m.def.dataAdapters
            .filter(adapter => !adapter.optional)
            .map(adapter => this.isRefAdapterConfig(adapter) ? adapter.ref : adapter.alias) || [];
        return React.createElement(LiveData, { requiredAdapterTypes: requiredAdapterTypes, asyncData: mapModuleData(m.def.dataAdapters, dataLoader, m.uuid), logger: this.props.logger, ContentComponent: contentComponentPromise, ErrorComponent: getErrorPlaceholder ? props => getErrorPlaceholder(props) : void 0, LoadingComponent: getLoadingPlaceholder ? props => getLoadingPlaceholder(props) : void 0, contentProps: {
                locale: this.props.locale,
                translation: this.translationStore.getTranslations(m.pluginUri),
                logger: this.props.logger,
                sidebarVisible: this.sidebarMobileStore.isSidebarVisible,
                uiStateContainer,
                slots: children,
                context,
                options: m.options
            } });
    }
    moduleHasAncestorWithHelp(m) {
        let currentNode = m;
        while (currentNode.parent) {
            if (this.isModule(currentNode.parent) && currentNode.parent.def.getHelpComponent) {
                return true;
            }
            currentNode = currentNode.parent;
        }
        return false;
    }
};
__decorate([
    observable.ref
], PageRenderer.prototype, "helpOpenFor", void 0);
PageRenderer = __decorate([
    observer
], PageRenderer);
export { PageRenderer };
//# sourceMappingURL=PageRenderer.js.map